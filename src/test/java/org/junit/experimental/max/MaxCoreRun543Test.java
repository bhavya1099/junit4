// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=run_c415277fec
ROOST_METHOD_SIG_HASH=run_120a3ac635
"""
  Scenario 1: Successful Execution of Run Method with Valid Request and Core Input
  Details:
    TestName: testRunWithValidInput.
    Description: This test is meant to check if the run method works as expected when provided with valid Request and JUnitCore inputs.
  Execution:
    Arrange: Create a valid Request object and a JUnitCore object. Also, ensure the history.listener() and sorted request runner objects are mocked correctly.
    Act: Invoke the run method with the created Request and JUnitCore objects.
    Assert: Verify whether the core.run method was called with the sorted request runner and also that the returned Result object is not null.
  Validation:
    This assert verifies if the method executes successfully with valid inputs. This is vital as the main functionality of running tests should work properly for valid inputs.
  Scenario 2: Execution of Run Method with Null Input
  Details:
    TestName: testRunWithNullInput.
    Description: This test case is designed to see how the run method handles null inputs.
  Execution:
    Arrange: No initialization would be required in this case.
    Act: Invoke the run method with null inputs.
    Assert: Check if the method throws the appropriate NullPointerException.
  Validation:
    The assertion aims to verify that the correct exception is thrown for null inputs. It is important in determining the robustness of the method against invalid inputs.
  Scenario 3: Handling of Errors When Sorting Request Fails
  Details:
    TestName: testRunWhenSortingRequestFails.
    Description: This test case is designed to see how the run method handles situations where sorting of requests fails due to some error.
  Execution:
    Arrange: Create the Request and JUnitCore objects. Also, mock the sortRequest method to throw an exception.
    Act: Invoke the run method with the created Request and JUnitCore objects.
    Assert: Check if the method throws the appropriate exception when sorting fails.
  Validation:
    The assertion aims to confirm that the method handles sorting errors appropriately. The test is significant as it checks the method's ability to handle errors during the process of sorting requests.
  Scenario 4: Handling of Errors When Listener Attachment Fails
  Details:
    TestName: testRunWhenListenerAttachmentFails.
    Description: The test checks how run method handles the failure of listener attachment process.
  Execution:
    Arrange: Create Request and JUnitCore objects. Ensure that the history.listener() mock is setup to throw an exception.
    Act: Invoke the run method with the created Request and JUnitCore objects.
    Assert: Verify if the method throws the appropriate exception on listener attachment failure.
  Validation:
    The assertion verifies that the method handles failure of attaching listeners properly. This is critical as failure in attaching listeners can stop test execution process.
"""
*/
// ********RoostGPT********
package org.junit.experimental.max;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.junit.jupiter.api.Test;
import org.junit.runner.JUnitCore;
import org.junit.runner.Request;
import org.junit.runner.Result;
import org.junit.runner.notification.RunListener;
import org.junit.runner.Runner;
import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import junit.framework.TestSuite;
import org.junit.internal.requests.SortingRequest;
import org.junit.internal.runners.ErrorReportingRunner;
import org.junit.internal.runners.JUnit38ClassRunner;
import org.junit.runner.Description;
import org.junit.runners.Suite;
import org.junit.runners.model.InitializationError;
import org.junit.jupiter.api.*;

@Tag("junit.framework")
@Tag("junit.framework.addListener")
@Tag("junit.textui")
@Tag("junit.textui.run")
@Tag("org.junit.experimental")
@Tag("org.junit.experimental.getRunner")
@Tag("org.junit.experimental.max")
@Tag("org.junit.experimental.max.run")
@Tag("org.junit.experimental.max.listener")
@Tag("org.junit.experimental.max.sortRequest")
class MaxCoreRun543Test {

	@Test
	void testRunWithValidInput() {
		// Arrange
		Request request = mock(Request.class);
		JUnitCore core = mock(JUnitCore.class);
		MaxHistory history = mock(MaxHistory.class);
		RunListener rememberingListener = mock(RunListener.class);
		when(history.listener()).thenReturn(rememberingListener);
		Runner sortedRunner = mock(Runner.class);
		Request sortedRequest = mock(Request.class);
		when(sortedRequest.getRunner()).thenReturn(sortedRunner);
		when(history.sortRequest(request)).thenReturn(sortedRequest);
		// Act
		MaxCore maxCore = new MaxCore(history);
		Result result = maxCore.run(request, core);
		// Assert
		verify(core).addListener(rememberingListener);
		verify(core).run(sortedRunner);
		assertNotNull(result);
	}

	@Test
	void testRunWithNullInput() {
		// Arrange
		MaxHistory history = mock(MaxHistory.class);
		// Act
		MaxCore maxCore = new MaxCore(history);
		// Assert
		assertThrows(NullPointerException.class, () -> maxCore.run(null, null));
	}

	@Test
	void testRunWhenSortingRequestFails() {
		// Arrange
		Request request = mock(Request.class);
		JUnitCore core = mock(JUnitCore.class);
		MaxHistory history = mock(MaxHistory.class);
		// make sortRequest throw RuntimeException
		when(history.sortRequest(request)).thenThrow(new RuntimeException("Mocked Exception"));
		// Act
		MaxCore maxCore = new MaxCore(history);
		// Assert
		assertThrows(RuntimeException.class, () -> maxCore.run(request, core));
	}

	@Test
	void testRunWhenListenerAttachmentFails() {
		// Arrange
		Request request = mock(Request.class);
		JUnitCore core = mock(JUnitCore.class);
		MaxHistory history = mock(MaxHistory.class);
		// make history.listener throw RuntimeException
		when(history.listener()).thenThrow(new RuntimeException("Mocked Exception"));
		// Act
		MaxCore maxCore = new MaxCore(history);
		// Assert
		assertThrows(RuntimeException.class, () -> maxCore.run(request, core));
	}

}