// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=testRunFinished_c6f24dcfe1
ROOST_METHOD_SIG_HASH=testRunFinished_f96576543c
"""
Scenario 1: Check if 'save' method is called when testRunFinished is invoked
Details:
  TestName: saveMethodInvocationCheck
  Description: This test will check if the method 'save' is called when the method testRunFinished is invoked.
Execution:
  Arrange: Mock the Result instance to pass as a parameter.
  Act: Invoke the testRunFinished method with the mocked Result.
  Assert: Verify that the 'save' method is called.
Validation:
  The assertion verifies if the 'save' method is invoked when testRunFinished is called. This helps ensure that the final state of the test run is correctly saved.
Scenario 2: Evaluate Exception handling when an exception is thrown from 'save' method
Details:
  TestName: exceptionHandlingCheck
  Description: This test will evaluate how testRunFinished handles exceptions thrown by the 'save' method.
Execution:
  Arrange: Mock the Result instance and setup 'save' method to throw an IOException.
  Act: Invoke the testRunFinished method with the mocked Result.
  Assert: Make sure the expected Exception is thrown.
Validation:
  The assertion verifies how the testRunFinished method handles an exception thrown from 'save' method. This is to confirm that proper error handling mechanisms are implemented.
Scenario 3: Check the initial state of the object before the completion of a test run
Details:
  TestName: initialStateCheckBeforeTestRunCompletion
  Description: This test will check the initial state of the object before the completion of a test run.
Execution:
  Arrange: Create an instance of the class and stop the test run before it is complete. Capture the state of the fDurations, fFailureTimestamps, and starts.
  Act: Invoke the testRunFinished method.
  Assert: Assert that the initial state of fDurations, fFailureTimestamps, and starts have changed.
Validation:
  This assertion checks if the described test run modification fields are changed after a test run finishes.
"""
*/
// ********RoostGPT********
package org.junit.experimental.max;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.mockito.Mockito.*;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.runner.Result;
import org.junit.experimental.max.MaxHistory;
import java.io.IOException;
import java.io.File;
import java.util.HashMap;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Comparator;
import java.util.Map;
import org.junit.runner.Description;
import org.junit.runner.notification.Failure;
import org.junit.runner.notification.RunListener;
import org.junit.jupiter.api.*;

@Tag("org.junit.experimental.max")
@Tag("org.junit.experimental.max.testRunFinished")
@Tag("org.junit.experimental.max.save")
class MaxHistoryTestRunFinishedTest {

	@Mock
	private Result result;

	private File storedResults;

	private MaxHistory maxHistory;

	@BeforeEach
	public void setUp() {
		MockitoAnnotations.initMocks(this);
		storedResults = new File("testResults");
		maxHistory = new MaxHistory(storedResults);
	}

	@Test
	void saveMethodInvocationCheck() {
		maxHistory.testRunFinished(result);
		try {
			verify(maxHistory).save();
		}
		catch (IOException e) {
			fail("IOException was not expected.");
		}
	}

	@Test
	void exceptionHandlingCheck() {
		doThrow(new IOException()).when(maxHistory).save();
		IOException exception = assertThrows(IOException.class, () -> {
			maxHistory.testRunFinished(result);
		});
		String expectedMessage = "Could not save test run history";
		assertTrue(exception.getMessage().contains(expectedMessage));
	}

	@Test
	void initialStateCheckBeforeTestRunCompletion() {
		HashMap<String, Long> initialFDurations = new HashMap<>(maxHistory.fDurations);
		HashMap<String, Long> initialFFailureTimestamps = new HashMap<>(maxHistory.fFailureTimestamps);
		HashMap<Description, Long> initialStarts = new HashMap<>(maxHistory.starts);
		maxHistory.testRunFinished(result);
		assertNotEquals(initialFDurations, maxHistory.fDurations);
		assertNotEquals(initialFFailureTimestamps, maxHistory.fFailureTimestamps);
		assertNotEquals(initialStarts, maxHistory.starts);
	}

}